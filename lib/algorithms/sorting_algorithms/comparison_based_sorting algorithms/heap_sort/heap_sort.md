heap sort it is similar to selection sort but its worse time complexity is O(n log n) which is better than O(n^2) time complexity for selection sort. You ***first heapify*** the list, then you ***swap the first element*** at index 0 with the last element at index n - 1(where n is the current heap size). After swap, the last element of the list is in the correct spot but invalidates the heap. Thus the ***second step is to sift the root element down*** until it land in its correct position excluding the last element of the list from the heap since you no longer consider it as part of the heap but of the sorted list. Then you repeat the process of swapping and sifting down incrementing the number of elements to be excluded on the rightmost side of the list by 1 each time you do swap + sifting down (since those elements will have already been sorted) until you reach a heap of size 1, in which the list will be fully sorted.

- The best, average and worse time complexity for heap sort is O(n log n). This uniformity in performance is because you have to traverse the whole list once, and every time you swap elements, you must perform a down-sift, which is an O(log n) operation.
- The space complexity is constant O(1) since their is no extra space used when sorting.
- Heap sort isn't stable sort i.e if you are heap sorting a deck of cards by their rank, you might see there suit change order compared to the original deck.

#### key points:
1. Heap sort leverage the heap data structure to sort elements in a list.
2. The algorithm works by moving the value from the top of the heap to and ordered list. (this is the same heap by virtually divided into to parts, the rightmost part which will contain the sorted values and the leftmost part which is in unsorted state) This can be performed in place if you use an index to separate the leftmost part of the heap from the sorted rightmost part of the list.